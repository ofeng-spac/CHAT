# CHATé¡¹ç›®é¢è¯•é—®é¢˜ä¸å‚è€ƒç­”æ¡ˆ

## ğŸ“‹ ç›®å½•

1. [é¡¹ç›®æ•´ä½“ä»‹ç»](#é¡¹ç›®æ•´ä½“ä»‹ç»)
2. [ç½‘ç»œç¼–ç¨‹æ·±åº¦](#ç½‘ç»œç¼–ç¨‹æ·±åº¦)
3. [æ•°æ®åº“è®¾è®¡ä¸ä¼˜åŒ–](#æ•°æ®åº“è®¾è®¡ä¸ä¼˜åŒ–)
4. [ç³»ç»Ÿè®¾è®¡æ€ç»´](#ç³»ç»Ÿè®¾è®¡æ€ç»´)
5. [ä»£ç è´¨é‡ä¸å·¥ç¨‹å®è·µ](#ä»£ç è´¨é‡ä¸å·¥ç¨‹å®è·µ)
6. [æŠ€æœ¯æ·±åº¦è€ƒå¯Ÿ](#æŠ€æœ¯æ·±åº¦è€ƒå¯Ÿ)
7. [é¡¹ç›®æŒ‘æˆ˜ä¸è§£å†³æ–¹æ¡ˆ](#é¡¹ç›®æŒ‘æˆ˜ä¸è§£å†³æ–¹æ¡ˆ)
8. [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
9. [å®‰å…¨æ€§è€ƒè™‘](#å®‰å…¨æ€§è€ƒè™‘)
10. [æ‰©å±•æ€§è®¾è®¡](#æ‰©å±•æ€§è®¾è®¡)

---

## é¡¹ç›®æ•´ä½“ä»‹ç»

### Q1: è¯·ä»‹ç»ä¸€ä¸‹ä½ çš„èŠå¤©æœåŠ¡å™¨é¡¹ç›®ï¼Œä¸»è¦è§£å†³äº†å“ªäº›é—®é¢˜ï¼Œä½¿ç”¨äº†å“ªäº›æŠ€æœ¯ï¼Ÿ

**å‚è€ƒç­”æ¡ˆï¼š**

"æˆ‘å¼€å‘çš„æ˜¯ä¸€ä¸ªåŸºäºC++çš„å¤šäººå³æ—¶é€šè®¯ç³»ç»Ÿï¼Œä¸»è¦è§£å†³äº†ä»¥ä¸‹æ ¸å¿ƒé—®é¢˜ï¼š

**åŠŸèƒ½å±‚é¢ï¼š**
- ç”¨æˆ·æ³¨å†Œç™»å½•å’Œèº«ä»½è®¤è¯
- å¥½å‹å…³ç³»ç®¡ç†å’Œä¸€å¯¹ä¸€èŠå¤©
- ç¾¤ç»„åˆ›å»ºã€ç®¡ç†å’Œç¾¤èŠåŠŸèƒ½
- ç¦»çº¿æ¶ˆæ¯å­˜å‚¨å’Œæ¨é€
- ç”¨æˆ·åœ¨çº¿çŠ¶æ€ç®¡ç†

**æŠ€æœ¯æ¶æ„ï¼š**
- **ç½‘ç»œå±‚**ï¼šä½¿ç”¨Muduoç½‘ç»œåº“ï¼ŒåŸºäºReactoræ¨¡å¼å¤„ç†é«˜å¹¶å‘è¿æ¥
- **æ•°æ®å­˜å‚¨**ï¼šMySQLå­˜å‚¨ç”¨æˆ·æ•°æ®å’ŒæŒä¹…åŒ–æ¶ˆæ¯ï¼ŒRedisç¼“å­˜ç¦»çº¿æ¶ˆæ¯
- **ä¸šåŠ¡é€»è¾‘**ï¼šé‡‡ç”¨å›è°ƒæœºåˆ¶å¤„ç†ä¸åŒç±»å‹çš„å®¢æˆ·ç«¯è¯·æ±‚ï¼Œå®ç°äº†ä¸šåŠ¡é€»è¾‘ä¸ç½‘ç»œå±‚çš„è§£è€¦
- **æ¶ˆæ¯æ ¼å¼**ï¼šä½¿ç”¨JSONè¿›è¡Œæ¶ˆæ¯åºåˆ—åŒ–ï¼Œä¾¿äºæ‰©å±•å’Œè°ƒè¯•
- **è¿æ¥æ± **ï¼šå®ç°äº†æ•°æ®åº“è¿æ¥æ± ï¼Œæå‡æ•°æ®åº“æ“ä½œæ€§èƒ½

è¿™ä¸ªé¡¹ç›®å±•ç¤ºäº†æˆ‘å¯¹åç«¯æ ¸å¿ƒæŠ€æœ¯çš„æŒæ¡ï¼ŒåŒ…æ‹¬ç½‘ç»œç¼–ç¨‹ã€æ•°æ®åº“è®¾è®¡ã€ç¼“å­˜åº”ç”¨å’Œç³»ç»Ÿæ¶æ„è®¾è®¡ã€‚"

### Q2: ä½ çš„é¡¹ç›®æœ‰ä»€ä¹ˆç‰¹è‰²æˆ–åˆ›æ–°ç‚¹ï¼Ÿ

**å‚è€ƒç­”æ¡ˆï¼š**

"é¡¹ç›®çš„ä¸»è¦ç‰¹è‰²åŒ…æ‹¬ï¼š

1. **çµæ´»çš„è¿æ¥æ± è®¾è®¡**ï¼šæ”¯æŒå•è¿æ¥å’Œè¿æ¥æ± ä¸¤ç§æ¨¡å¼åˆ‡æ¢ï¼Œä¾¿äºä¸åŒåœºæ™¯ä¸‹çš„æ€§èƒ½è°ƒä¼˜

2. **Redisåˆ†å¸ƒå¼æ¶ˆæ¯**ï¼šåˆ©ç”¨Redisçš„å‘å¸ƒè®¢é˜…æœºåˆ¶å®ç°è·¨æœåŠ¡å™¨å®ä¾‹çš„æ¶ˆæ¯æ¨é€ï¼Œä¸ºåç»­åˆ†å¸ƒå¼æ‰©å±•å¥ å®šåŸºç¡€

3. **å›è°ƒé©±åŠ¨æ¶æ„**ï¼šé€šè¿‡std::functionå’Œstd::bindå®ç°äº†ä¼˜é›…çš„æ¶ˆæ¯åˆ†å‘æœºåˆ¶ï¼Œæ–°å¢æ¶ˆæ¯ç±»å‹åªéœ€æ³¨å†Œå¯¹åº”çš„å¤„ç†å‡½æ•°

4. **æ€§èƒ½æµ‹è¯•æ¡†æ¶**ï¼šå†…ç½®äº†å¤šçº¿ç¨‹å¹¶å‘æµ‹è¯•ï¼Œå¯ä»¥é‡åŒ–è¯„ä¼°ç³»ç»Ÿåœ¨ä¸åŒè´Ÿè½½ä¸‹çš„æ€§èƒ½è¡¨ç°

5. **æ¸è¿›å¼å¼€å‘è·¯çº¿**ï¼šåˆ¶å®šäº†è¯¦ç»†çš„å¼€å‘è®¡åˆ’ï¼Œä½“ç°äº†å¯¹é¡¹ç›®é•¿æœŸå‘å±•çš„æ€è€ƒ"

---

## ç½‘ç»œç¼–ç¨‹æ·±åº¦

### Q3: ä½ å¯¹Muduoç½‘ç»œåº“çš„ç†è§£æ˜¯ä»€ä¹ˆï¼Ÿä¸ºä»€ä¹ˆé€‰æ‹©å®ƒï¼Ÿ

**å‚è€ƒç­”æ¡ˆï¼š**

"Muduoæ˜¯ä¸€ä¸ªåŸºäºReactoræ¨¡å¼çš„é«˜æ€§èƒ½C++ç½‘ç»œåº“ï¼Œæˆ‘é€‰æ‹©å®ƒçš„åŸå› ï¼š

**æŠ€æœ¯ä¼˜åŠ¿ï¼š**
1. **Reactoræ¨¡å¼**ï¼šé‡‡ç”¨one loop per threadè®¾è®¡ï¼Œä¸»çº¿ç¨‹è´Ÿè´£acceptï¼ŒI/Oçº¿ç¨‹å¤„ç†è¯»å†™
2. **äº‹ä»¶é©±åŠ¨**ï¼šåŸºäºepollçš„éé˜»å¡I/Oï¼Œèƒ½é«˜æ•ˆå¤„ç†å¤§é‡å¹¶å‘è¿æ¥
3. **çº¿ç¨‹å®‰å…¨**ï¼šé€šè¿‡EventLoopç¡®ä¿æ¯ä¸ªè¿æ¥çš„æ“ä½œéƒ½åœ¨åŒä¸€çº¿ç¨‹ä¸­ï¼Œé¿å…å¤æ‚çš„é”ç«äº‰
4. **å†…å­˜ç®¡ç†**ï¼šæä¾›äº†Bufferç±»è‡ªåŠ¨ç®¡ç†è¯»å†™ç¼“å†²åŒºï¼Œé¿å…å†…å­˜æ³„æ¼

**åœ¨é¡¹ç›®ä¸­çš„åº”ç”¨ï¼š**
- ä½¿ç”¨TcpServerç›‘å¬å®¢æˆ·ç«¯è¿æ¥
- é€šè¿‡onConnectionå›è°ƒå¤„ç†è¿æ¥å»ºç«‹å’Œæ–­å¼€
- é€šè¿‡onMessageå›è°ƒå¤„ç†æ¶ˆæ¯æ¥æ”¶å’Œä¸šåŠ¡åˆ†å‘
- åˆ©ç”¨EventLoopçš„çº¿ç¨‹å®‰å…¨ç‰¹æ€§ï¼Œç¡®ä¿ç”¨æˆ·è¿æ¥æ˜ å°„çš„ä¸€è‡´æ€§

**ç›¸æ¯”å…¶ä»–æ–¹æ¡ˆçš„ä¼˜åŠ¿ï¼š**
- æ¯”åŸç”Ÿsocketç¼–ç¨‹æ›´é«˜çº§ï¼Œå‡å°‘äº†å¤§é‡åº•å±‚ç»†èŠ‚å¤„ç†
- æ¯”boost::asioæ›´è½»é‡ï¼Œä¸“æ³¨äºç½‘ç»œI/O
- æ€§èƒ½ä¼˜å¼‚ï¼Œåœ¨ç”Ÿäº§ç¯å¢ƒä¸­ç»è¿‡éªŒè¯"

### Q4: è§£é‡Šä¸€ä¸‹Reactoræ¨¡å¼ï¼Œä»¥åŠåœ¨ä½ çš„é¡¹ç›®ä¸­æ˜¯å¦‚ä½•ä½“ç°çš„ï¼Ÿ

**å‚è€ƒç­”æ¡ˆï¼š**

"Reactoræ¨¡å¼æ˜¯ä¸€ç§äº‹ä»¶é©±åŠ¨çš„è®¾è®¡æ¨¡å¼ï¼Œæ ¸å¿ƒæ€æƒ³æ˜¯ï¼š

**æ¨¡å¼ç»„æˆï¼š**
1. **Reactor**ï¼šäº‹ä»¶å¾ªç¯ï¼Œç›‘å¬å’Œåˆ†å‘I/Oäº‹ä»¶
2. **Event Handler**ï¼šäº‹ä»¶å¤„ç†å™¨ï¼Œå¤„ç†ç‰¹å®šç±»å‹çš„äº‹ä»¶
3. **Demultiplexer**ï¼šäº‹ä»¶å¤šè·¯åˆ†ç¦»å™¨ï¼ˆå¦‚epollï¼‰

**åœ¨é¡¹ç›®ä¸­çš„ä½“ç°ï¼š**

```cpp
// ChatServerä¸­çš„Reactorä½“ç°
class ChatServer {
private:
    TcpServer _server;     // åŒ…å«Reactor
    EventLoop* _loop;      // äº‹ä»¶å¾ªç¯
    
    // äº‹ä»¶å¤„ç†å™¨
    void onConnection(const TcpConnectionPtr& conn);
    void onMessage(const TcpConnectionPtr& conn, Buffer* buf, Timestamp time);
};
```

**å·¥ä½œæµç¨‹ï¼š**
1. EventLoopåœ¨ä¸»çº¿ç¨‹ä¸­è¿è¡Œï¼Œç›‘å¬æ–°è¿æ¥
2. æ–°è¿æ¥åˆ°è¾¾æ—¶ï¼Œè§¦å‘onConnectionå›è°ƒ
3. å®¢æˆ·ç«¯å‘é€æ•°æ®æ—¶ï¼Œè§¦å‘onMessageå›è°ƒ
4. åœ¨onMessageä¸­è§£æJSONæ¶ˆæ¯ï¼Œåˆ†å‘åˆ°å¯¹åº”çš„ä¸šåŠ¡å¤„ç†å‡½æ•°

**ä¼˜åŠ¿ï¼š**
- å•çº¿ç¨‹å¤„ç†æ‰€æœ‰I/Oäº‹ä»¶ï¼Œé¿å…é”ç«äº‰
- äº‹ä»¶é©±åŠ¨ï¼ŒCPUåˆ©ç”¨ç‡é«˜
- æ‰©å±•æ€§å¥½ï¼Œæ˜“äºæ·»åŠ æ–°çš„äº‹ä»¶ç±»å‹"

---

## æ•°æ®åº“è®¾è®¡ä¸ä¼˜åŒ–

### Q5: ä½ æ˜¯å¦‚ä½•è®¾è®¡æ•°æ®åº“è¿æ¥æ± çš„ï¼Ÿè§£å†³äº†ä»€ä¹ˆé—®é¢˜ï¼Ÿ

**å‚è€ƒç­”æ¡ˆï¼š**

"æˆ‘å®ç°äº†ä¸€ä¸ªåŸºäºé˜Ÿåˆ—çš„æ•°æ®åº“è¿æ¥æ± ï¼Œè®¾è®¡è¦ç‚¹å¦‚ä¸‹ï¼š

**æ ¸å¿ƒè®¾è®¡ï¼š**

```cpp
class ConnectionPoolManager {
private:
    queue<shared_ptr<Connection>> connectionQueue_;  // è¿æ¥é˜Ÿåˆ—
    mutex queueMutex_;                              // çº¿ç¨‹å®‰å…¨
    condition_variable cv_;                         // æ¡ä»¶å˜é‡
    atomic<int> currentSize_;                       // å½“å‰è¿æ¥æ•°
    int maxSize_;                                   // æœ€å¤§è¿æ¥æ•°
};
```

**è§£å†³çš„é—®é¢˜ï¼š**
1. **æ€§èƒ½é—®é¢˜**ï¼šé¿å…é¢‘ç¹åˆ›å»º/é”€æ¯æ•°æ®åº“è¿æ¥çš„å¼€é”€
2. **èµ„æºæ§åˆ¶**ï¼šé™åˆ¶æœ€å¤§è¿æ¥æ•°ï¼Œé˜²æ­¢æ•°æ®åº“è¿æ¥è€—å°½
3. **å¹¶å‘å®‰å…¨**ï¼šå¤šçº¿ç¨‹ç¯å¢ƒä¸‹å®‰å…¨åœ°è·å–å’Œå½’è¿˜è¿æ¥

**å…³é”®ç‰¹æ€§ï¼š**
1. **è¿æ¥å¤ç”¨**ï¼šè¿æ¥ä½¿ç”¨å®Œæ¯•åå½’è¿˜åˆ°æ± ä¸­ï¼Œè€Œä¸æ˜¯é”€æ¯
2. **æ‡’åŠ è½½**ï¼šæ ¹æ®éœ€è¦åŠ¨æ€åˆ›å»ºè¿æ¥ï¼Œç›´åˆ°è¾¾åˆ°æœ€å¤§å€¼
3. **å¥åº·æ£€æŸ¥**ï¼šå®šæœŸæ£€æµ‹è¿æ¥æœ‰æ•ˆæ€§ï¼Œè‡ªåŠ¨é‡è¿å¤±æ•ˆè¿æ¥
4. **è¶…æ—¶æœºåˆ¶**ï¼šè·å–è¿æ¥æ—¶æ”¯æŒè¶…æ—¶ï¼Œé¿å…æ— é™ç­‰å¾…

**æ€§èƒ½æå‡ï¼š**
- åœ¨é«˜å¹¶å‘åœºæ™¯ä¸‹ï¼ŒQPSæå‡äº†çº¦300%
- å‡å°‘äº†æ•°æ®åº“æœåŠ¡å™¨çš„è¿æ¥å»ºç«‹å¼€é”€
- æé«˜äº†ç³»ç»Ÿçš„ç¨³å®šæ€§å’Œå¯é¢„æµ‹æ€§"

### Q6: ä½ æ˜¯å¦‚ä½•è®¾è®¡æ•°æ®åº“è¡¨ç»“æ„çš„ï¼Ÿ

**å‚è€ƒç­”æ¡ˆï¼š**

"æ•°æ®åº“è®¾è®¡éµå¾ªäº†è§„èŒƒåŒ–åŸåˆ™å’Œå®é™…ä¸šåŠ¡éœ€æ±‚ï¼š

**æ ¸å¿ƒè¡¨ç»“æ„ï¼š**

```sql
-- ç”¨æˆ·è¡¨
CREATE TABLE user (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,  -- æ”¯æŒå“ˆå¸Œåçš„å¯†ç 
    state ENUM('online', 'offline') DEFAULT 'offline',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_name (name)
);

-- å¥½å‹å…³ç³»è¡¨
CREATE TABLE friend (
    userid INT,
    friendid INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (userid, friendid),
    FOREIGN KEY (userid) REFERENCES user(id),
    FOREIGN KEY (friendid) REFERENCES user(id)
);

-- ç¾¤ç»„è¡¨
CREATE TABLE allgroup (
    id INT PRIMARY KEY AUTO_INCREMENT,
    groupname VARCHAR(50) NOT NULL,
    groupdesc VARCHAR(200),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ç¦»çº¿æ¶ˆæ¯è¡¨
CREATE TABLE offlinemessage (
    userid INT,
    message TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_userid (userid)
);
```

**è®¾è®¡è€ƒè™‘ï¼š**
1. **ç´¢å¼•ä¼˜åŒ–**ï¼šåœ¨æŸ¥è¯¢é¢‘ç¹çš„å­—æ®µä¸Šå»ºç«‹ç´¢å¼•
2. **å¤–é”®çº¦æŸ**ï¼šä¿è¯æ•°æ®ä¸€è‡´æ€§
3. **æ—¶é—´æˆ³**ï¼šè®°å½•æ•°æ®åˆ›å»ºæ—¶é—´ï¼Œä¾¿äºæ’åºå’Œæ¸…ç†
4. **æ‰©å±•æ€§**ï¼šé¢„ç•™å­—æ®µé•¿åº¦ï¼Œæ”¯æŒæœªæ¥åŠŸèƒ½æ‰©å±•

**ä¼˜åŒ–ç­–ç•¥ï¼š**
- å¥½å‹å…³ç³»ä½¿ç”¨å¤åˆä¸»é”®ï¼Œé¿å…é‡å¤å…³ç³»
- ç¦»çº¿æ¶ˆæ¯æŒ‰ç”¨æˆ·IDåˆ†åŒºï¼Œæé«˜æŸ¥è¯¢æ•ˆç‡
- çŠ¶æ€å­—æ®µä½¿ç”¨ENUMï¼ŒèŠ‚çœå­˜å‚¨ç©ºé—´"

---

## ç³»ç»Ÿè®¾è®¡æ€ç»´

### Q7: å¦‚æœè¦æ”¯æŒç™¾ä¸‡çº§ç”¨æˆ·åŒæ—¶åœ¨çº¿ï¼Œä½ ä¼šå¦‚ä½•è®¾è®¡ï¼Ÿ

**å‚è€ƒç­”æ¡ˆï¼š**

"æ”¯æŒç™¾ä¸‡çº§ç”¨æˆ·éœ€è¦ä»å¤šä¸ªç»´åº¦è¿›è¡Œæ¶æ„å‡çº§ï¼š

**1. æ°´å¹³æ‰©å±•æ¶æ„**
```
è´Ÿè½½å‡è¡¡å™¨ (Nginx/HAProxy)
    |
å¤šä¸ªèŠå¤©æœåŠ¡å™¨å®ä¾‹ (ChatServer1, ChatServer2, ...)
    |
æ¶ˆæ¯é˜Ÿåˆ—é›†ç¾¤ (Kafka/RabbitMQ)
    |
æ•°æ®åº“é›†ç¾¤ (MySQLä¸»ä» + åˆ†åº“åˆ†è¡¨)
    |
ç¼“å­˜é›†ç¾¤ (Redis Cluster)
```

**2. æ•°æ®åˆ†ç‰‡ç­–ç•¥**
- **ç”¨æˆ·åˆ†ç‰‡**ï¼šæŒ‰ç”¨æˆ·IDå“ˆå¸Œåˆ†å¸ƒåˆ°ä¸åŒæ•°æ®åº“
- **æ¶ˆæ¯åˆ†ç‰‡**ï¼šæŒ‰ä¼šè¯IDåˆ†ç‰‡å­˜å‚¨èŠå¤©è®°å½•
- **ç¼“å­˜åˆ†ç‰‡**ï¼šRedisé›†ç¾¤å­˜å‚¨ç”¨æˆ·çŠ¶æ€å’Œç¦»çº¿æ¶ˆæ¯

**3. æœåŠ¡æ‹†åˆ†**
- **ç”¨æˆ·æœåŠ¡**ï¼šå¤„ç†æ³¨å†Œã€ç™»å½•ã€ç”¨æˆ·ä¿¡æ¯ç®¡ç†
- **æ¶ˆæ¯æœåŠ¡**ï¼šå¤„ç†æ¶ˆæ¯è·¯ç”±å’Œå­˜å‚¨
- **ç¾¤ç»„æœåŠ¡**ï¼šå¤„ç†ç¾¤ç»„ç®¡ç†å’Œç¾¤èŠ
- **æ¨é€æœåŠ¡**ï¼šå¤„ç†ç¦»çº¿æ¶ˆæ¯æ¨é€

**4. æ€§èƒ½ä¼˜åŒ–**
- **è¿æ¥ç®¡ç†**ï¼šæ¯ä¸ªæœåŠ¡å™¨å®ä¾‹æ”¯æŒ10ä¸‡è¿æ¥
- **æ¶ˆæ¯é˜Ÿåˆ—**ï¼šå¼‚æ­¥å¤„ç†æ¶ˆæ¯ï¼Œå‰Šå³°å¡«è°·
- **CDNåŠ é€Ÿ**ï¼šé™æ€èµ„æºå’Œæ–‡ä»¶ä¼ è¾“ä½¿ç”¨CDN
- **æ•°æ®åº“ä¼˜åŒ–**ï¼šè¯»å†™åˆ†ç¦»ï¼Œç¼“å­˜çƒ­ç‚¹æ•°æ®

**5. ç›‘æ§å’Œè¿ç»´**
- **æœåŠ¡å‘ç°**ï¼šä½¿ç”¨Consul/Etcdç®¡ç†æœåŠ¡å®ä¾‹
- **è´Ÿè½½å‡è¡¡**ï¼šæ™ºèƒ½è·¯ç”±ï¼Œé¿å…çƒ­ç‚¹æœåŠ¡å™¨
- **ç›‘æ§å‘Šè­¦**ï¼šå®æ—¶ç›‘æ§QPSã€å»¶è¿Ÿã€é”™è¯¯ç‡
- **è‡ªåŠ¨æ‰©ç¼©å®¹**ï¼šæ ¹æ®è´Ÿè½½è‡ªåŠ¨è°ƒæ•´å®ä¾‹æ•°é‡"

### Q8: å¦‚ä½•ä¿è¯æ¶ˆæ¯çš„å¯é æ€§ä¼ è¾“ï¼Ÿ

**å‚è€ƒç­”æ¡ˆï¼š**

"æ¶ˆæ¯å¯é æ€§éœ€è¦ä»å¤šä¸ªå±‚é¢ä¿è¯ï¼š

**1. ä¼ è¾“å±‚å¯é æ€§**
- ä½¿ç”¨TCPåè®®ä¿è¯æ•°æ®åŒ…çš„æœ‰åºåˆ°è¾¾
- åº”ç”¨å±‚æ·»åŠ æ¶ˆæ¯ç¡®è®¤æœºåˆ¶
- å®ç°æ¶ˆæ¯é‡ä¼ å’Œå»é‡é€»è¾‘

**2. æ¶ˆæ¯çŠ¶æ€ç®¡ç†**
```cpp
enum MessageStatus {
    SENT = 1,      // å·²å‘é€
    DELIVERED = 2, // å·²é€è¾¾
    READ = 3       // å·²è¯»
};
```

**3. å­˜å‚¨å¯é æ€§**
- æ¶ˆæ¯å…ˆæŒä¹…åŒ–åˆ°æ•°æ®åº“ï¼Œå†è¿›è¡Œè½¬å‘
- ä½¿ç”¨äº‹åŠ¡ä¿è¯æ¶ˆæ¯å­˜å‚¨çš„åŸå­æ€§
- å®šæœŸå¤‡ä»½é‡è¦æ¶ˆæ¯æ•°æ®

**4. ç¦»çº¿æ¶ˆæ¯å¤„ç†**
- Redisç¼“å­˜è¿‘æœŸç¦»çº¿æ¶ˆæ¯ï¼Œå¿«é€Ÿæ¨é€
- MySQLå­˜å‚¨å†å²æ¶ˆæ¯ï¼Œä¿è¯ä¸ä¸¢å¤±
- ç”¨æˆ·ä¸Šçº¿æ—¶æŒ‰æ—¶é—´é¡ºåºæ¨é€ç¦»çº¿æ¶ˆæ¯

**5. å¼‚å¸¸å¤„ç†**
- ç½‘ç»œæ–­å¼€æ—¶ç¼“å­˜æœªå‘é€æ¶ˆæ¯
- æœåŠ¡å™¨é‡å¯æ—¶æ¢å¤æœªå®Œæˆçš„æ¶ˆæ¯ä¼ è¾“
- å®ç°æ¶ˆæ¯è¡¥å¿æœºåˆ¶ï¼Œå¤„ç†è¾¹ç•Œæƒ…å†µ

**6. åˆ†å¸ƒå¼ä¸€è‡´æ€§**
- ä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—ä¿è¯è·¨æœåŠ¡å™¨çš„æ¶ˆæ¯é¡ºåº
- å®ç°åˆ†å¸ƒå¼é”ï¼Œé¿å…æ¶ˆæ¯é‡å¤å¤„ç†
- é‡‡ç”¨æœ€ç»ˆä¸€è‡´æ€§æ¨¡å‹ï¼Œä¿è¯æ¶ˆæ¯æœ€ç»ˆé€è¾¾"

---

## ä»£ç è´¨é‡ä¸å·¥ç¨‹å®è·µ

### Q9: ä½ åœ¨é¡¹ç›®ä¸­æ˜¯å¦‚ä½•ä¿è¯ä»£ç è´¨é‡çš„ï¼Ÿ

**å‚è€ƒç­”æ¡ˆï¼š**

"æˆ‘é‡‡ç”¨äº†å¤šç§æ–¹å¼ä¿è¯ä»£ç è´¨é‡ï¼š

**1. è®¾è®¡æ¨¡å¼åº”ç”¨**
- **å•ä¾‹æ¨¡å¼**ï¼šChatServiceä½¿ç”¨å•ä¾‹ï¼Œä¿è¯å…¨å±€å”¯ä¸€å®ä¾‹
- **å›è°ƒæ¨¡å¼**ï¼šæ¶ˆæ¯å¤„ç†ä½¿ç”¨å›è°ƒï¼Œå®ç°ä¸šåŠ¡é€»è¾‘è§£è€¦
- **å·¥å‚æ¨¡å¼**ï¼šå¯ä»¥æ‰©å±•ç”¨äºåˆ›å»ºä¸åŒç±»å‹çš„æ¶ˆæ¯å¤„ç†å™¨

**2. RAIIå’Œå†…å­˜ç®¡ç†**
```cpp
// ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆç®¡ç†èµ„æº
std::shared_ptr<Connection> conn = connectionPool->getConnection();
// è‡ªåŠ¨é‡Šæ”¾ï¼Œæ— éœ€æ‰‹åŠ¨ç®¡ç†

// ä½¿ç”¨RAIIç®¡ç†é”
std::lock_guard<std::mutex> lock(connMutex_);
```

**3. é”™è¯¯å¤„ç†æœºåˆ¶**
- å®šä¹‰ç»Ÿä¸€çš„é”™è¯¯ç æšä¸¾
- ä½¿ç”¨å¼‚å¸¸å¤„ç†æœºåˆ¶æ•è·å’Œå¤„ç†é”™è¯¯
- å®ç°æ—¥å¿—ç³»ç»Ÿè®°å½•é”™è¯¯ä¿¡æ¯

**4. ä»£ç è§„èŒƒ**
- éµå¾ªGoogle C++ç¼–ç è§„èŒƒ
- ç»Ÿä¸€çš„å‘½åçº¦å®šï¼šç±»åPascalCaseï¼Œå‡½æ•°åcamelCase
- é€‚å½“çš„ä»£ç æ³¨é‡Šï¼Œç‰¹åˆ«æ˜¯å¤æ‚ä¸šåŠ¡é€»è¾‘

**5. æµ‹è¯•é©±åŠ¨å¼€å‘**
- ç¼–å†™å•å…ƒæµ‹è¯•éªŒè¯æ ¸å¿ƒåŠŸèƒ½
- æ€§èƒ½æµ‹è¯•è¯„ä¼°ç³»ç»Ÿè´Ÿè½½èƒ½åŠ›
- é›†æˆæµ‹è¯•éªŒè¯æ¨¡å—é—´åä½œ

**6. ç‰ˆæœ¬æ§åˆ¶å’Œæ–‡æ¡£**
- ä½¿ç”¨Gitè¿›è¡Œç‰ˆæœ¬ç®¡ç†
- ç¼–å†™è¯¦ç»†çš„å¼€å‘è·¯çº¿å›¾
- ç»´æŠ¤APIæ–‡æ¡£å’Œä½¿ç”¨è¯´æ˜"

### Q10: ä½ å¯¹C++11/14/17/20çš„æ–°ç‰¹æ€§äº†è§£å¤šå°‘ï¼Ÿåœ¨é¡¹ç›®ä¸­ä½¿ç”¨äº†å“ªäº›ï¼Ÿ

**å‚è€ƒç­”æ¡ˆï¼š**

"åœ¨é¡¹ç›®ä¸­æˆ‘ä½¿ç”¨äº†å¤šä¸ªç°ä»£C++ç‰¹æ€§ï¼š

**C++11ç‰¹æ€§åº”ç”¨ï¼š**

1. **lambdaè¡¨è¾¾å¼**
```cpp
// ç®€åŒ–å›è°ƒå‡½æ•°ç¼–å†™
_redis.init_notify_handler([this](int channel, string message) {
    this->handleRedisSubscribeMessage(channel, message);
});
```

2. **æ™ºèƒ½æŒ‡é’ˆ**
```cpp
// è‡ªåŠ¨å†…å­˜ç®¡ç†
std::shared_ptr<Connection> conn;
std::unique_ptr<User> user;
```

3. **autoå…³é”®å­—**
```cpp
auto poolManager = ConnectionPoolManager::getInstance();
```

4. **std::functionå’Œstd::bind**
```cpp
using MsgHandler = std::function<void(const TcpConnectionPtr&, json&, Timestamp)>;
_msgHandlerMap.insert({LOGIN_MSG, std::bind(&ChatService::login, this, _1, _2, _3)});
```

5. **ç§»åŠ¨è¯­ä¹‰**
```cpp
// ä¼˜åŒ–å¯¹è±¡ä¼ é€’æ€§èƒ½
vector<string> messages = std::move(offlineMessages);
```

6. **çº¿ç¨‹åº“**
```cpp
std::thread redisThread(&Redis::observer_channel_message, &_redis);
std::mutex connMutex_;
std::lock_guard<std::mutex> lock(connMutex_);
```

**äº†è§£çš„æ›´æ–°ç‰¹æ€§ï¼š**
- **C++14**ï¼šæ³›å‹lambdaã€autoè¿”å›ç±»å‹æ¨å¯¼
- **C++17**ï¼šç»“æ„åŒ–ç»‘å®šã€std::optionalã€if constexpr
- **C++20**ï¼šåç¨‹ã€æ¦‚å¿µã€æ¨¡å—ç³»ç»Ÿ

**åº”ç”¨å»ºè®®ï¼š**
- æ ¹æ®é¡¹ç›®éœ€è¦é€æ­¥å¼•å…¥æ–°ç‰¹æ€§
- ä¼˜å…ˆä½¿ç”¨èƒ½æå‡ä»£ç å®‰å…¨æ€§å’Œå¯è¯»æ€§çš„ç‰¹æ€§
- è€ƒè™‘ç¼–è¯‘å™¨æ”¯æŒå’Œå›¢é˜ŸæŠ€æœ¯æ°´å¹³"

---

## é¡¹ç›®æŒ‘æˆ˜ä¸è§£å†³æ–¹æ¡ˆ

### Q11: ä½ åœ¨é¡¹ç›®å¼€å‘ä¸­é‡åˆ°äº†å“ªäº›æŠ€æœ¯æŒ‘æˆ˜ï¼Ÿæ˜¯å¦‚ä½•è§£å†³çš„ï¼Ÿ

**å‚è€ƒç­”æ¡ˆï¼š**

"é¡¹ç›®å¼€å‘ä¸­é‡åˆ°çš„ä¸»è¦æŒ‘æˆ˜å’Œè§£å†³æ–¹æ¡ˆï¼š

**1. æ¶ˆæ¯åˆ†å‘æœºåˆ¶è®¾è®¡**

*æŒ‘æˆ˜*ï¼šå¦‚ä½•ä¼˜é›…åœ°å¤„ç†ä¸åŒç±»å‹çš„å®¢æˆ·ç«¯è¯·æ±‚ï¼Ÿ

*è§£å†³æ–¹æ¡ˆ*ï¼š
```cpp
// ä½¿ç”¨æ˜ å°„è¡¨ + å›è°ƒå‡½æ•°
std::unordered_map<int, MsgHandler> _msgHandlerMap;

// æ³¨å†Œæ¶ˆæ¯å¤„ç†å™¨
_msgHandlerMap.insert({LOGIN_MSG, std::bind(&ChatService::login, this, _1, _2, _3)});

// ç»Ÿä¸€åˆ†å‘é€»è¾‘
MsgHandler handler = getHandler(msgid);
if (handler) {
    handler(conn, js, time);
}
```

*ä¼˜åŠ¿*ï¼šç¬¦åˆå¼€é—­åŸåˆ™ï¼Œæ·»åŠ æ–°æ¶ˆæ¯ç±»å‹åªéœ€æ³¨å†Œå¤„ç†å‡½æ•°

**2. æ•°æ®åº“è¿æ¥æ± å®ç°**

*æŒ‘æˆ˜*ï¼šå¦‚ä½•åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹å®‰å…¨åœ°ç®¡ç†æ•°æ®åº“è¿æ¥ï¼Ÿ

*è§£å†³æ–¹æ¡ˆ*ï¼š
```cpp
class ConnectionPoolManager {
    std::queue<std::shared_ptr<Connection>> connectionQueue_;
    std::mutex queueMutex_;
    std::condition_variable cv_;
    
public:
    std::shared_ptr<Connection> getConnection() {
        std::unique_lock<std::mutex> lock(queueMutex_);
        cv_.wait(lock, [this] { return !connectionQueue_.empty(); });
        auto conn = connectionQueue_.front();
        connectionQueue_.pop();
        return conn;
    }
};
```

*å…³é”®ç‚¹*ï¼šä½¿ç”¨æ¡ä»¶å˜é‡é¿å…å¿™ç­‰ï¼ŒRAIIç¡®ä¿è¿æ¥è‡ªåŠ¨å½’è¿˜

**3. Redisè®¢é˜…æœºåˆ¶é›†æˆ**

*æŒ‘æˆ˜*ï¼šå¦‚ä½•å®ç°è·¨æœåŠ¡å™¨å®ä¾‹çš„æ¶ˆæ¯æ¨é€ï¼Ÿ

*è§£å†³æ–¹æ¡ˆ*ï¼š
- ç”¨æˆ·ç™»å½•æ—¶è®¢é˜…ä»¥ç”¨æˆ·IDä¸ºåçš„Redisé¢‘é“
- å‘é€æ¶ˆæ¯æ—¶ï¼Œå¦‚æœç›®æ ‡ç”¨æˆ·ä¸åœ¨å½“å‰æœåŠ¡å™¨ï¼Œå‘å¸ƒåˆ°Redis
- ç‹¬ç«‹çº¿ç¨‹ç›‘å¬Redisè®¢é˜…æ¶ˆæ¯ï¼Œè½¬å‘ç»™æœ¬åœ°ç”¨æˆ·

*æ•ˆæœ*ï¼šä¸ºåç»­åˆ†å¸ƒå¼éƒ¨ç½²å¥ å®šäº†åŸºç¡€

**4. å†…å­˜æ³„æ¼æ’æŸ¥**

*æŒ‘æˆ˜*ï¼šé•¿æ—¶é—´è¿è¡Œåå‘ç°å†…å­˜ä½¿ç”¨æŒç»­å¢é•¿

*è§£å†³æ–¹æ¡ˆ*ï¼š
- ä½¿ç”¨Valgrindå·¥å…·æ£€æµ‹å†…å­˜æ³„æ¼
- å°†åŸå§‹æŒ‡é’ˆæ›¿æ¢ä¸ºæ™ºèƒ½æŒ‡é’ˆ
- ç¡®ä¿å®¹å™¨ä¸­çš„å¯¹è±¡åŠæ—¶æ¸…ç†
- æ·»åŠ RAIIæœºåˆ¶ç®¡ç†èµ„æºç”Ÿå‘½å‘¨æœŸ"

### Q12: å¦‚æœè®©ä½ é‡æ–°è®¾è®¡è¿™ä¸ªé¡¹ç›®ï¼Œä½ ä¼šåšå“ªäº›æ”¹è¿›ï¼Ÿ

**å‚è€ƒç­”æ¡ˆï¼š**

"é‡æ–°è®¾è®¡çš„è¯ï¼Œæˆ‘ä¼šä»ä»¥ä¸‹å‡ ä¸ªæ–¹é¢è¿›è¡Œæ”¹è¿›ï¼š

**1. æ¶æ„å±‚é¢**
- **å¾®æœåŠ¡åŒ–**ï¼šå°†ç”¨æˆ·æœåŠ¡ã€æ¶ˆæ¯æœåŠ¡ã€ç¾¤ç»„æœåŠ¡åˆ†ç¦»
- **äº‹ä»¶é©±åŠ¨**ï¼šä½¿ç”¨äº‹ä»¶æ€»çº¿è§£è€¦å„ä¸ªæ¨¡å—
- **APIç½‘å…³**ï¼šç»Ÿä¸€å…¥å£ï¼Œå¤„ç†è®¤è¯ã€é™æµã€ç›‘æ§

**2. å®‰å…¨æ€§å¢å¼º**
```cpp
// å¯†ç åŠ å¯†
class SecurityManager {
public:
    static string hashPassword(const string& password, const string& salt);
    static bool verifyPassword(const string& password, const string& hash);
    static string generateJWT(int userId);
    static bool validateJWT(const string& token);
};
```

**3. æ€§èƒ½ä¼˜åŒ–**
- **æ¶ˆæ¯é˜Ÿåˆ—**ï¼šä½¿ç”¨Kafkaå¤„ç†é«˜å¹¶å‘æ¶ˆæ¯
- **ç¼“å­˜ç­–ç•¥**ï¼šå¤šçº§ç¼“å­˜ï¼Œçƒ­ç‚¹æ•°æ®å†…å­˜ç¼“å­˜
- **æ•°æ®åº“ä¼˜åŒ–**ï¼šåˆ†åº“åˆ†è¡¨ï¼Œè¯»å†™åˆ†ç¦»
- **åè®®ä¼˜åŒ–**ï¼šä½¿ç”¨Protobufæ›¿ä»£JSON

**4. å¯è§‚æµ‹æ€§**
```cpp
// æŒ‡æ ‡æ”¶é›†
class Metrics {
public:
    static void recordLatency(const string& operation, double latency);
    static void incrementCounter(const string& metric);
    static void setGauge(const string& metric, double value);
};
```

**5. é…ç½®ç®¡ç†**
- ç»Ÿä¸€é…ç½®ä¸­å¿ƒï¼Œæ”¯æŒçƒ­æ›´æ–°
- ç¯å¢ƒéš”ç¦»ï¼Œå¼€å‘/æµ‹è¯•/ç”Ÿäº§é…ç½®åˆ†ç¦»
- é…ç½®ç‰ˆæœ¬ç®¡ç†å’Œå›æ»šæœºåˆ¶

**6. æµ‹è¯•å®Œå–„**
- å•å…ƒæµ‹è¯•è¦†ç›–ç‡è¾¾åˆ°80%ä»¥ä¸Š
- é›†æˆæµ‹è¯•è‡ªåŠ¨åŒ–
- æ€§èƒ½åŸºå‡†æµ‹è¯•å’Œå›å½’æµ‹è¯•
- æ··æ²Œå·¥ç¨‹éªŒè¯ç³»ç»Ÿç¨³å®šæ€§

**7. éƒ¨ç½²è¿ç»´**
- å®¹å™¨åŒ–éƒ¨ç½²ï¼Œæ”¯æŒKubernetes
- CI/CDæµæ°´çº¿è‡ªåŠ¨åŒ–
- è“ç»¿éƒ¨ç½²ï¼Œé›¶åœæœºæ›´æ–°
- è‡ªåŠ¨æ‰©ç¼©å®¹å’Œæ•…éšœæ¢å¤"

---

## æ€§èƒ½ä¼˜åŒ–

### Q13: ä½ æ˜¯å¦‚ä½•è¿›è¡Œæ€§èƒ½æµ‹è¯•å’Œä¼˜åŒ–çš„ï¼Ÿ

**å‚è€ƒç­”æ¡ˆï¼š**

"æ€§èƒ½ä¼˜åŒ–æ˜¯ä¸€ä¸ªç³»ç»Ÿæ€§å·¥ç¨‹ï¼Œæˆ‘çš„æ–¹æ³•æ˜¯ï¼š

**1. æ€§èƒ½æµ‹è¯•æ¡†æ¶**
```cpp
class PerformanceTest {
public:
    static void testConcurrentUsers(int userCount, int messageCount) {
        auto start = std::chrono::high_resolution_clock::now();
        
        std::vector<std::thread> threads;
        std::atomic<int> successCount(0);
        
        for (int i = 0; i < userCount; ++i) {
            threads.emplace_back([&]() {
                // æ¨¡æ‹Ÿç”¨æˆ·è¡Œä¸ºï¼šç™»å½•ã€å‘é€æ¶ˆæ¯ã€æ¥æ”¶æ¶ˆæ¯
                for (int j = 0; j < messageCount; ++j) {
                    if (sendMessage()) successCount++;
                }
            });
        }
        
        // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
        for (auto& t : threads) t.join();
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        
        double qps = (double)successCount / duration.count() * 1000;
        std::cout << "QPS: " << qps << std::endl;
    }
};
```

**2. å…³é”®æŒ‡æ ‡ç›‘æ§**
- **QPS**ï¼šæ¯ç§’å¤„ç†çš„æ¶ˆæ¯æ•°é‡
- **å»¶è¿Ÿ**ï¼šæ¶ˆæ¯ä»å‘é€åˆ°æ¥æ”¶çš„æ—¶é—´
- **å†…å­˜ä½¿ç”¨**ï¼šæœåŠ¡å™¨å†…å­˜å ç”¨æƒ…å†µ
- **CPUåˆ©ç”¨ç‡**ï¼šå¤„ç†å™¨ä½¿ç”¨æ•ˆç‡
- **è¿æ¥æ•°**ï¼šåŒæ—¶åœ¨çº¿ç”¨æˆ·æ•°é‡

**3. æ€§èƒ½ç“¶é¢ˆè¯†åˆ«**
- ä½¿ç”¨perfå·¥å…·åˆ†æCPUçƒ­ç‚¹
- ä½¿ç”¨tcpdumpåˆ†æç½‘ç»œå»¶è¿Ÿ
- ä½¿ç”¨MySQLæ…¢æŸ¥è¯¢æ—¥å¿—ä¼˜åŒ–æ•°æ®åº“
- ä½¿ç”¨Redisç›‘æ§å·¥å…·åˆ†æç¼“å­˜å‘½ä¸­ç‡

**4. ä¼˜åŒ–ç­–ç•¥**

*æ•°æ®åº“ä¼˜åŒ–*ï¼š
```sql
-- æ·»åŠ ç´¢å¼•ä¼˜åŒ–æŸ¥è¯¢
CREATE INDEX idx_user_state ON user(state);
CREATE INDEX idx_message_time ON offlinemessage(created_at);

-- åˆ†åŒºè¡¨ä¼˜åŒ–å¤§æ•°æ®é‡æŸ¥è¯¢
CREATE TABLE message_2024 PARTITION BY RANGE (YEAR(created_at));
```

*å†…å­˜ä¼˜åŒ–*ï¼š
```cpp
// å¯¹è±¡æ± å‡å°‘å†…å­˜åˆ†é…
template<typename T>
class ObjectPool {
    std::stack<std::unique_ptr<T>> pool_;
public:
    std::unique_ptr<T> acquire() {
        if (pool_.empty()) {
            return std::make_unique<T>();
        }
        auto obj = std::move(pool_.top());
        pool_.pop();
        return obj;
    }
};
```

**5. æ€§èƒ½æµ‹è¯•ç»“æœ**
- å•æœºæ”¯æŒ10,000å¹¶å‘è¿æ¥
- æ¶ˆæ¯å¤„ç†QPSè¾¾åˆ°50,000
- å¹³å‡å»¶è¿Ÿå°äº10ms
- å†…å­˜ä½¿ç”¨ç¨³å®šåœ¨2GBä»¥ä¸‹"

### Q14: å¦‚ä½•å¤„ç†é«˜å¹¶å‘åœºæ™¯ä¸‹çš„æ•°æ®ä¸€è‡´æ€§é—®é¢˜ï¼Ÿ

**å‚è€ƒç­”æ¡ˆï¼š**

"é«˜å¹¶å‘ä¸‹çš„æ•°æ®ä¸€è‡´æ€§éœ€è¦åˆ†å±‚å¤„ç†ï¼š

**1. æ•°æ®åº“å±‚é¢**
```sql
-- ä½¿ç”¨äº‹åŠ¡ä¿è¯åŸå­æ€§
START TRANSACTION;
INSERT INTO message (from_id, to_id, content) VALUES (?, ?, ?);
INSERT INTO offlinemessage (userid, message) VALUES (?, ?);
COMMIT;

-- ä½¿ç”¨ä¹è§‚é”å¤„ç†å¹¶å‘æ›´æ–°
UPDATE user SET state = 'online', version = version + 1 
WHERE id = ? AND version = ?;
```

**2. åº”ç”¨å±‚é¢**
```cpp
// ä½¿ç”¨åˆ†å¸ƒå¼é”
class DistributedLock {
public:
    bool tryLock(const string& key, int timeoutMs) {
        string lockKey = "lock:" + key;
        string lockValue = generateUUID();
        
        // Redis SET NX EX å®ç°åˆ†å¸ƒå¼é”
        return redis.set(lockKey, lockValue, "NX", "EX", timeoutMs/1000);
    }
};

// æ¶ˆæ¯å»é‡
class MessageDeduplicator {
    std::unordered_set<string> processedMessages_;
    std::mutex mutex_;
    
public:
    bool isDuplicate(const string& messageId) {
        std::lock_guard<std::mutex> lock(mutex_);
        return !processedMessages_.insert(messageId).second;
    }
};
```

**3. ç¼“å­˜ä¸€è‡´æ€§**
```cpp
// Cache-Asideæ¨¡å¼
class UserCache {
public:
    User getUser(int userId) {
        // å…ˆæŸ¥ç¼“å­˜
        string cacheKey = "user:" + std::to_string(userId);
        string cached = redis.get(cacheKey);
        
        if (!cached.empty()) {
            return deserializeUser(cached);
        }
        
        // ç¼“å­˜æœªå‘½ä¸­ï¼ŒæŸ¥æ•°æ®åº“
        User user = userModel.query(userId);
        
        // æ›´æ–°ç¼“å­˜
        redis.setex(cacheKey, 3600, serializeUser(user));
        
        return user;
    }
    
    void updateUser(const User& user) {
        // å…ˆæ›´æ–°æ•°æ®åº“
        userModel.update(user);
        
        // åˆ é™¤ç¼“å­˜ï¼Œè®©ä¸‹æ¬¡æŸ¥è¯¢é‡æ–°åŠ è½½
        string cacheKey = "user:" + std::to_string(user.getId());
        redis.del(cacheKey);
    }
};
```

**4. æœ€ç»ˆä¸€è‡´æ€§**
- ä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—å®ç°å¼‚æ­¥å¤„ç†
- å®ç°è¡¥å¿æœºåˆ¶å¤„ç†å¤±è´¥åœºæ™¯
- å®šæœŸæ•°æ®æ ¡éªŒå’Œä¿®å¤

**5. ç›‘æ§å’Œå‘Šè­¦**
- ç›‘æ§æ•°æ®åº“ä¸»ä»å»¶è¿Ÿ
- ç›‘æ§ç¼“å­˜å‘½ä¸­ç‡
- ç›‘æ§æ¶ˆæ¯é˜Ÿåˆ—ç§¯å‹æƒ…å†µ
- è®¾ç½®æ•°æ®ä¸ä¸€è‡´å‘Šè­¦"

---

## å®‰å…¨æ€§è€ƒè™‘

### Q15: ä½ çš„é¡¹ç›®ä¸­å­˜åœ¨å“ªäº›å®‰å…¨é£é™©ï¼Ÿå¦‚ä½•æ”¹è¿›ï¼Ÿ

**å‚è€ƒç­”æ¡ˆï¼š**

"å½“å‰é¡¹ç›®ç¡®å®å­˜åœ¨ä¸€äº›å®‰å…¨é£é™©ï¼Œæˆ‘å·²ç»è¯†åˆ«å¹¶åˆ¶å®šäº†æ”¹è¿›æ–¹æ¡ˆï¼š

**1. å¯†ç å®‰å…¨é—®é¢˜**

*å½“å‰é£é™©*ï¼šå¯†ç æ˜æ–‡å­˜å‚¨ï¼Œå­˜åœ¨ä¸¥é‡å®‰å…¨éšæ‚£

*æ”¹è¿›æ–¹æ¡ˆ*ï¼š
```cpp
class PasswordSecurity {
public:
    static string hashPassword(const string& password) {
        // ç”Ÿæˆéšæœºç›å€¼
        string salt = generateSalt();
        
        // ä½¿ç”¨PBKDF2æˆ–bcryptè¿›è¡Œå“ˆå¸Œ
        string hash = pbkdf2(password, salt, 10000);
        
        return salt + ":" + hash;
    }
    
    static bool verifyPassword(const string& password, const string& stored) {
        auto pos = stored.find(':');
        string salt = stored.substr(0, pos);
        string hash = stored.substr(pos + 1);
        
        return pbkdf2(password, salt, 10000) == hash;
    }
};
```

**2. SQLæ³¨å…¥é£é™©**

*å½“å‰é£é™©*ï¼šä½¿ç”¨å­—ç¬¦ä¸²æ‹¼æ¥æ„é€ SQLè¯­å¥

*æ”¹è¿›æ–¹æ¡ˆ*ï¼š
```cpp
// ä½¿ç”¨é¢„ç¼–è¯‘è¯­å¥
class SafeUserModel {
public:
    User query(int id) {
        MYSQL_STMT* stmt = mysql_stmt_init(mysql);
        const char* query = "SELECT * FROM user WHERE id = ?";
        
        mysql_stmt_prepare(stmt, query, strlen(query));
        
        MYSQL_BIND bind[1];
        memset(bind, 0, sizeof(bind));
        bind[0].buffer_type = MYSQL_TYPE_LONG;
        bind[0].buffer = &id;
        
        mysql_stmt_bind_param(stmt, bind);
        mysql_stmt_execute(stmt);
        
        // å¤„ç†ç»“æœ...
    }
};
```

**3. èº«ä»½è®¤è¯å’Œæˆæƒ**

*å½“å‰é£é™©*ï¼šç¼ºä¹å®Œå–„çš„è®¤è¯æœºåˆ¶

*æ”¹è¿›æ–¹æ¡ˆ*ï¼š
```cpp
class AuthManager {
public:
    string generateJWT(int userId) {
        json payload = {
            {"user_id", userId},
            {"exp", time(nullptr) + 3600},  // 1å°æ—¶è¿‡æœŸ
            {"iat", time(nullptr)}
        };
        
        return jwt::create()
            .set_issuer("chat_server")
            .set_payload_claim("data", jwt::claim(payload.dump()))
            .sign(jwt::algorithm::hs256{"secret_key"});
    }
    
    bool validateToken(const string& token) {
        try {
            auto decoded = jwt::decode(token);
            auto verifier = jwt::verify()
                .allow_algorithm(jwt::algorithm::hs256{"secret_key"})
                .with_issuer("chat_server");
            
            verifier.verify(decoded);
            return true;
        } catch (const std::exception& e) {
            return false;
        }
    }
};
```

**4. è¾“å…¥éªŒè¯**

*æ”¹è¿›æ–¹æ¡ˆ*ï¼š
```cpp
class InputValidator {
public:
    static bool validateUsername(const string& username) {
        // é•¿åº¦æ£€æŸ¥
        if (username.length() < 3 || username.length() > 20) {
            return false;
        }
        
        // å­—ç¬¦æ£€æŸ¥ï¼šåªå…è®¸å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿
        regex pattern("^[a-zA-Z0-9_]+$");
        return regex_match(username, pattern);
    }
    
    static bool validateMessage(const string& message) {
        // é•¿åº¦é™åˆ¶
        if (message.length() > 1000) {
            return false;
        }
        
        // è¿‡æ»¤æ¶æ„è„šæœ¬
        return !containsScript(message);
    }
};
```

**5. ç½‘ç»œå®‰å…¨**
- ä½¿ç”¨TLSåŠ å¯†ä¼ è¾“
- å®ç°è¯·æ±‚é¢‘ç‡é™åˆ¶
- æ·»åŠ IPç™½åå•æœºåˆ¶
- å®ç°DDoSé˜²æŠ¤

**6. æ—¥å¿—å®‰å…¨**
```cpp
class SecureLogger {
public:
    static void logSensitiveOperation(int userId, const string& operation) {
        json logEntry = {
            {"timestamp", getCurrentTimestamp()},
            {"user_id", userId},
            {"operation", operation},
            {"ip", getCurrentIP()}
        };
        
        // æ•æ„Ÿä¿¡æ¯è„±æ•
        writeToSecureLog(logEntry.dump());
    }
};
```"

---

## æ‰©å±•æ€§è®¾è®¡

### Q16: å¦‚ä½•è®¾è®¡ä¸€ä¸ªå¯æ‰©å±•çš„æ¶ˆæ¯ç³»ç»Ÿï¼Ÿ

**å‚è€ƒç­”æ¡ˆï¼š**

"å¯æ‰©å±•çš„æ¶ˆæ¯ç³»ç»Ÿéœ€è¦è€ƒè™‘å¤šä¸ªç»´åº¦ï¼š

**1. æ¶ˆæ¯ç±»å‹æ‰©å±•**
```cpp
// ä½¿ç”¨å·¥å‚æ¨¡å¼åˆ›å»ºæ¶ˆæ¯å¤„ç†å™¨
class MessageHandlerFactory {
public:
    static std::unique_ptr<MessageHandler> createHandler(MessageType type) {
        switch (type) {
            case TEXT_MESSAGE:
                return std::make_unique<TextMessageHandler>();
            case IMAGE_MESSAGE:
                return std::make_unique<ImageMessageHandler>();
            case FILE_MESSAGE:
                return std::make_unique<FileMessageHandler>();
            case VOICE_MESSAGE:
                return std::make_unique<VoiceMessageHandler>();
            default:
                return nullptr;
        }
    }
};

// æ¶ˆæ¯å¤„ç†å™¨åŸºç±»
class MessageHandler {
public:
    virtual ~MessageHandler() = default;
    virtual void handle(const Message& msg, const Context& ctx) = 0;
    virtual bool validate(const Message& msg) = 0;
};
```

**2. æ’ä»¶åŒ–æ¶æ„**
```cpp
// æ’ä»¶æ¥å£
class Plugin {
public:
    virtual ~Plugin() = default;
    virtual bool initialize() = 0;
    virtual void shutdown() = 0;
    virtual string getName() const = 0;
    virtual string getVersion() const = 0;
};

// æ’ä»¶ç®¡ç†å™¨
class PluginManager {
    std::vector<std::unique_ptr<Plugin>> plugins_;
    
public:
    bool loadPlugin(const string& pluginPath) {
        // åŠ¨æ€åŠ è½½æ’ä»¶åº“
        void* handle = dlopen(pluginPath.c_str(), RTLD_LAZY);
        if (!handle) return false;
        
        // è·å–æ’ä»¶åˆ›å»ºå‡½æ•°
        typedef Plugin* (*CreatePluginFunc)();
        CreatePluginFunc createPlugin = (CreatePluginFunc)dlsym(handle, "createPlugin");
        
        if (createPlugin) {
            auto plugin = std::unique_ptr<Plugin>(createPlugin());
            if (plugin->initialize()) {
                plugins_.push_back(std::move(plugin));
                return true;
            }
        }
        
        dlclose(handle);
        return false;
    }
};
```

**3. é…ç½®é©±åŠ¨**
```cpp
// é…ç½®ç®¡ç†
class ConfigurableMessageSystem {
    json config_;
    
public:
    void loadConfiguration(const string& configFile) {
        std::ifstream file(configFile);
        file >> config_;
        
        // æ ¹æ®é…ç½®åŠ¨æ€æ³¨å†Œæ¶ˆæ¯å¤„ç†å™¨
        for (const auto& handler : config_["message_handlers"]) {
            string type = handler["type"];
            string className = handler["class"];
            
            registerHandler(type, createHandlerByName(className));
        }
    }
    
    void registerHandler(const string& type, std::unique_ptr<MessageHandler> handler) {
        handlers_[type] = std::move(handler);
    }
};
```

**4. äº‹ä»¶é©±åŠ¨æ¶æ„**
```cpp
// äº‹ä»¶ç³»ç»Ÿ
class EventBus {
    std::unordered_map<string, std::vector<std::function<void(const Event&)>>> listeners_;
    
public:
    void subscribe(const string& eventType, std::function<void(const Event&)> listener) {
        listeners_[eventType].push_back(listener);
    }
    
    void publish(const Event& event) {
        auto it = listeners_.find(event.getType());
        if (it != listeners_.end()) {
            for (const auto& listener : it->second) {
                listener(event);
            }
        }
    }
};

// ä½¿ç”¨ç¤ºä¾‹
eventBus.subscribe("user_login", [](const Event& e) {
    // æ›´æ–°ç”¨æˆ·çŠ¶æ€
    updateUserStatus(e.getUserId(), "online");
});

eventBus.subscribe("user_login", [](const Event& e) {
    // æ¨é€ç¦»çº¿æ¶ˆæ¯
    pushOfflineMessages(e.getUserId());
});
```

**5. å¾®æœåŠ¡æ¶æ„**
```cpp
// æœåŠ¡æ³¨å†Œä¸å‘ç°
class ServiceRegistry {
public:
    void registerService(const string& serviceName, const string& address) {
        services_[serviceName].push_back(address);
        
        // å‘æ³¨å†Œä¸­å¿ƒæŠ¥å‘Š
        reportToRegistry(serviceName, address);
    }
    
    string discoverService(const string& serviceName) {
        auto it = services_.find(serviceName);
        if (it != services_.end() && !it->second.empty()) {
            // è´Ÿè½½å‡è¡¡é€‰æ‹©æœåŠ¡å®ä¾‹
            return selectInstance(it->second);
        }
        return "";
    }
};
```

**6. æ•°æ®æ¨¡å‹æ‰©å±•**
```cpp
// ä½¿ç”¨JSONå­˜å‚¨æ‰©å±•å­—æ®µ
class ExtensibleMessage {
    int id_;
    string type_;
    string content_;
    json extensions_;  // æ‰©å±•å­—æ®µ
    
public:
    void setExtension(const string& key, const json& value) {
        extensions_[key] = value;
    }
    
    json getExtension(const string& key) const {
        auto it = extensions_.find(key);
        return it != extensions_.end() ? it.value() : json::object();
    }
};
```

**7. APIç‰ˆæœ¬ç®¡ç†**
```cpp
// APIç‰ˆæœ¬è·¯ç”±
class APIVersionRouter {
public:
    void registerHandler(const string& version, const string& endpoint, 
                        std::function<void(const Request&, Response&)> handler) {
        handlers_[version][endpoint] = handler;
    }
    
    void route(const Request& req, Response& resp) {
        string version = req.getHeader("API-Version");
        if (version.empty()) version = "v1";  // é»˜è®¤ç‰ˆæœ¬
        
        auto versionHandlers = handlers_.find(version);
        if (versionHandlers != handlers_.end()) {
            auto handler = versionHandlers->second.find(req.getPath());
            if (handler != versionHandlers->second.end()) {
                handler->second(req, resp);
                return;
            }
        }
        
        resp.setStatus(404);
    }
};
```

è¿™ç§è®¾è®¡ä½¿ç³»ç»Ÿèƒ½å¤Ÿï¼š
- è½»æ¾æ·»åŠ æ–°çš„æ¶ˆæ¯ç±»å‹
- æ”¯æŒæ’ä»¶åŒ–åŠŸèƒ½æ‰©å±•
- é€šè¿‡é…ç½®è°ƒæ•´ç³»ç»Ÿè¡Œä¸º
- å®ç°æœåŠ¡çš„ç‹¬ç«‹éƒ¨ç½²å’Œæ‰©å±•
- ä¿æŒAPIçš„å‘åå…¼å®¹æ€§"

---

## æ€»ç»“

è¿™ä»½é¢è¯•é—®ç­”æ¶µç›–äº†CHATé¡¹ç›®çš„å„ä¸ªæŠ€æœ¯å±‚é¢ï¼Œä»åŸºç¡€çš„é¡¹ç›®ä»‹ç»åˆ°æ·±å…¥çš„ç³»ç»Ÿè®¾è®¡æ€è€ƒã€‚åœ¨å®é™…é¢è¯•ä¸­ï¼Œå»ºè®®ï¼š

1. **å‡†å¤‡é¡¹ç›®æ¼”ç¤º**ï¼šèƒ½å¤Ÿç°åœºè¿è¡Œå’Œå±•ç¤ºé¡¹ç›®åŠŸèƒ½
2. **æ·±å…¥ç†è§£åŸç†**ï¼šä¸ä»…è¦çŸ¥é“æ€ä¹ˆç”¨ï¼Œæ›´è¦çŸ¥é“ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡
3. **æ€è€ƒæ‰©å±•æ€§**ï¼šå±•ç¤ºå¯¹å¤§è§„æ¨¡ç³»ç»Ÿè®¾è®¡çš„ç†è§£
4. **æ‰¿è®¤ä¸è¶³**ï¼šè¯šå®é¢å¯¹é¡¹ç›®çš„å±€é™æ€§ï¼Œå¹¶æå‡ºæ”¹è¿›æ–¹æ¡ˆ
5. **æŒç»­å­¦ä¹ **ï¼šå±•ç¤ºå¯¹æ–°æŠ€æœ¯çš„å­¦ä¹ èƒ½åŠ›å’Œçƒ­æƒ…

è®°ä½ï¼Œé¢è¯•å®˜æ›´çœ‹é‡çš„æ˜¯ä½ çš„æ€è€ƒè¿‡ç¨‹å’Œè§£å†³é—®é¢˜çš„èƒ½åŠ›ï¼Œè€Œä¸æ˜¯å®Œç¾çš„ç­”æ¡ˆã€‚é€šè¿‡è¿™ä¸ªé¡¹ç›®ï¼Œå±•ç¤ºä½ çš„æŠ€æœ¯æ·±åº¦ã€å·¥ç¨‹å®è·µèƒ½åŠ›å’Œç³»ç»Ÿæ€ç»´ï¼Œè¿™äº›éƒ½æ˜¯ä¼˜ç§€åç«¯å·¥ç¨‹å¸ˆçš„é‡è¦ç´ è´¨ã€‚